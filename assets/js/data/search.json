[ { "title": "C语言：宏", "url": "/posts/clang-macro/", "categories": "learn, clang", "tags": "C语言, 编程", "date": "2022-09-21 16:47:35 +0000", "snippet": "虽然在较为现代的编程语言中，宏是个很少见的概念，C++虽然兼容C语法而保留了宏的概念，但也并不提倡使用宏。并且宏也是导致种种bug和难以理解的代码的常见根源之一。尽管如此，宏在C语言中的作用却是无可替代的，作为C程序员只有理解了宏，才能正确的使用宏，真正了解代码中各类宏的含义，同时避免陷入各类宏陷阱当中。宏的作用和处理时间首先必须明白，宏的核心作用是给代码段以名字，然后用代码段去替代后续代码中名字出现的地方。因此宏的实质就是文本替换，其操作由预处理器执行，在预处理处理注释之后。编译器的作用时间在预处理器之后，因此编译错误都是在宏展开后再进行检测的。宏的两种类型宏有两者类型：不带参数的宏和带参数的宏。不带参数的宏其性质多类似于对象，而带参数的宏其性质多类似于函数。既然函数可以不带参数，因此也有部分不带参数的宏性质更类似于函数。不带参数的宏不带参数的宏其性质多类似于对象。带参数的宏字符串化陷阱嵌套宏" }, { "title": "Go：函数", "url": "/posts/go-function/", "categories": "learn, golang", "tags": "Go语言, 编程", "date": "2022-09-19 15:46:16 +0000", "snippet": "引言本文基于Go 1.19版本。声明Go语言中，函数的声明由名字、形参列表、返回列表（可选）和函数体构成，注意Go对代码格式要求比较严格：func name(parameter-list) (result-list) { body}声明的组成成分函数的名字和其他名字有着同样的规则，由字母或下划线开头，后面可以跟任意数量的字符、数字和下划线，并且区分大小写。函数的形参列表由一组变量的参数名和参数类型构成。函数的形参变量由函数的实参的值进行初始化，为函数最外层作用域的局部变量。函数的返回列表制定了返回值的类型和名字（可选）。如果函数的没有返回值或只有一个未命名的返回值是，返回列表的圆括号可以省略。命名的返回值会根据变量类型初始化为相应的0值，和形参变量一样，同为函数最外层作用域的局部变量。存在返回列表时，无论返回值有没有得到命名，函数必须显式地以return结束。如下，return不能省略：func sub(x int, y int) (z int) { z = x - y return}相同类型简写当多个形参或返回值的类型相同时，可以采用简写的方式，只写一次类型。如下的两个声明完全等价：func f(i, j, k, int, s, t string ) { /* ... */}func f(i int, j int, k int, s string, t string) { /* ... */}函数签名及其等价性函数的类型被称为函数签名，如果两个函数的形参列表和返回列表相同（形参和返回值的名称不影响），则认为两个函数的类型是相同的。如下的两个函数签名即是相同的：func add(a int, b int) int { return a + b}func sub(x int, y int) (z int) { z = x - y return}无默认参数Go语言中没有默认参数值，也不能指定实参名，因此GO语言中需要提供实参来对应函数中的每个形参，并保持调用顺序的一致。以下在Python中的语法，Go中不存在：def func(a=2, b=3, c=5): return a + 2*b + 3*c# 2+2*3+3*5 = 23print(func())# 1+2*3+3*5 = 22print(func(1))# 2+2*4+3*1 = 13print(func(c=1, b=4, a=2))按值传递和C语言类似的，Go语言的实参也是按值传递的，修改函数的形参变量并不会影响被调用者提供的实参。当然，可以通过指针、slice等特定形参变量间接修改实参的变量。无函数体的声明Go语言中存在没有函数体的函数声明，这样的函数是由其他语言实现的：package mathfunc Sin(x float64) float64 // 使用汇编语言实现" }, { "title": "Python中的对象", "url": "/posts/python-object/", "categories": "learn, python", "tags": "Python, 编程", "date": "2022-09-13 17:31:55 +0000", "snippet": "引言对象是Python 中对数据的抽象。Python程序中的所有数据都是由对象或对象间关系来表示的。Python中，一切皆对象。本文基于Python 3.10。对象的组成在Python中，任何对象都有各自的标识号、类型和值。标识号（identity）一个对象被创建后，其标识号就绝不会改变。通过id()函数可以返回代表对象标识号的整数，is运算符可以用于判断两个对象标识号是否相同。我们可以将对象的标识号理解为该对象在内存中的地址，实际上，在CPython中，id(x)就是存放x的内存的地址。类型（type）对象的类型决定该对象所支持的操作并且定义了该类型的对象可能的取值。type()函数能返回一个对象的类型 (类型本身也是对象)。与标识号一样，一个对象的类型通常是不可改变的。文档脚注中提到： 在某些情况下有可能基于可控的条件改变一个对象的类型。 但这通常不是个好主意，因为如果处理不当会导致一些非常怪异的行为。Python是强类型的（strongly typed）作为术语，强类型的和弱类型的的定义并不算精确，实际上编程语言中类型系统（type system）中的许多术语都有类似的问题，如类型安全（type safety），这些术语在不同场景其内涵可能有微妙的差别。也正因如此，在讨论语言的类型系统相关问题时，更应该注意其类型系统设计上的种种具体特性，而不能简单的以一句话结论带过。Python被广泛认为是强类型的，其原因大概有如下几条： Python的对象类型不会发生隐式转换。 Python会在运行中检测类型错误。以上皆以Python的标准实现CPython为基准。实际上，很多编程语言特性是很难脱离了编译器/解释器对语言的具体实现来谈论的。Python是动态类型的（dynamic typed）Python也被广泛认为是动态类型的，其原因大概有如下几条： Python的名称（详见下文）可以换绑不同类型的对象。 Python在运行时会进行动态类型检查。同样以Python的标准实现CPython为基准。关于类型系统的相关讨论还能有更多，但正如上面所说，我们应该更注意其具体的特性，有关类型系统的其他内容放在词法分析、执行模型等部分分别来介绍可能会理解起来更为顺畅。值（value）有些对象的值可以改变。值可以改变的对象被称为可变对象；值不可以改变的对象就被称为不可变对象。有关可变对象和不可变对象，我们会在下文做详细介绍。名称/标识符（name, aka. identifier）和对象以如下代码为例：a = 1“a”即是名称（又可称为标识符），名称不是对象的组成部分，但名称可以指代对象。名称通过绑定（binding）操作引入，方式可以有多种： 函数的正式参数， 类定义， 函数定义， 赋值表达式, 如果在一个赋值中出现，则为标识符的目标: for循环头, 在as后面的with语句，except子句或结构模式匹配中的as模式。 在结构模式匹配中的捕获模式 import语句。对于从没有相应机制语言转过来的程序员，此概念可能较为难以理解。如在C语言中，类似a = 1的语句中，a作为变量其内存地址是确定的，再执行a = 2语句，则会对a对应的内存地址的值做更改，而在Python中，这只是将该名称绑定到另一个对象上，其对象所在的内存地址已经发生了改变。可变性（immutable）可变性的定义Python中，对象可以依照可变性分为两类：可变对象和不可变对象。在官方文档中，可变性的定义如下： immutable An object with a fixed value. Immutable objects include numbers, strings and tuples. Such an object cannot be altered. A new object has to be created if a different value has to be stored. They play an important role in places where a constant hash value is needed, for example as a key in a dictionary.固定值是可变对象的最根本的属性，因此在Python的赋值语句中，如果左侧为不可变对象，则通常需要创建新的对象，再将名称和新对象绑定。实际上，考虑到容器的情况，不可变和值不可改变间仍然有着微妙的区别，我们并不能严格意义上说两者是等价的。最后，对象的可变性是由其类型决定的。常见类型的可变性既然对象的可变性是由其类型决定的，那我们就能够谈论不同对象类型的可变性。常见类型中，数字、字符串和元组是不可变的，而字典和列表是可变的。不可变容器中的可变对象之前提到，不可变和值不可改变间是有微妙区别的，其原因就在于在不可变容器对象如元组中，如果含有可变对象的引用，但该可变对象改变时，该不可变容器的值也会改变，但我们仍然认为其属于不可变对象，因为该容器所包含的对象集不变。可以这么说，在容器对象中，可变性和不可变性是有其包含的对象是否可变来决定的。自定义类的可变性用户自定义类通常是可变的。但可以通过定义__slots的属性，替换__dict__属性，阻止属性的新增，再覆盖类中的__setattr__方法以阻止修改现有属性。class ImmutableClass(object): # __slots__可被赋值为任何非字符串的可迭代对象 __slots__ = ['attr1', 'attr2'] def __init__(self, attr1， attr2): super(ImmutableClass, self).__setattr__('attr1', attr1) super(ImmutableClass, self).__setattr__('attr2', attr2) def __setattr__(self, name, value): raise AttributeError(\"'%s' has no attribute %s\" % (self.__class__, name))可变对象作为函数参数默认值时的陷阱下面是官方文档中给出的经典的错误示范，在foo函数执行到第二回时，如果其key不同，将会导致mydict中含有两个数据项，而不是字面上所被理解的只有一个。其根本原因在于，mydict的默认值{}并不会在每次调用时创建新对象，而是仅仅在函数定义时创建一次，这样第二次调用该函数时，mydict绑定的对象和第一次调用时是同样的对象。def foo(mydict={}): # Danger: shared reference to one dict for all calls ... compute something ... mydict[key] = value return mydict为了避免此问题，建议采用不可变对象None作为默认值并用于新建列表、字典等其他对象。官网中给出来的示例写法如下：def foo(mydict=None): if mydict is None: mydict = {} # create a new dict for local namespace可哈希性（hashable）可变性与可哈希性的关系生命周期" }, { "title": "Python内存", "url": "/posts/python-memory/", "categories": "learn, python", "tags": "Python, 编程", "date": "2022-09-12 12:47:01 +0000", "snippet": "小整数对象池和大整数对象池Python的解释机制和内存PyFunctionObject" }, { "title": "读过的推理书", "url": "/posts/detective-fiction-list/", "categories": "book, detective", "tags": "推理, 阅读", "date": "2022-09-07 15:05:29 +0000", "snippet": "书单 福尔摩斯探案全集（上中下） 布朗神父探案全集（上下） 罗杰疑案 东方快车谋杀案 中国橘子之谜 三口棺材 ABC谋杀案 尼罗河上的惨案 犹大之窗 扭曲的铰链 无人生还 阳光下的罪恶 捕鼠器 时间的女儿 点与线·零的焦点 大唐狄公案 大唐狄公案 大唐狄公案 大唐狄公案 砂器 十角馆事件 有翼之暗 钟表馆事件 解体诸因 狱门岛 恶魔吹着笛子来 占星术杀人魔法 北方夕鹤2/3杀人事件 斜屋犯罪 奇想，天动 异邦骑士 X的悲剧 Y的悲剧 Z的悲剧 本阵杀人事件 希腊棺材之谜 埃及十字架之谜 东京空港杀人案 刺青杀人事件 只有猫知道 第七重解答 哲瑞·雷恩的最后一案 全部成为F 高层饭店的死角 恶意 诗人 嫌疑人X的献身 人骨拼图 斯泰尔斯庄园奇案 一朵桔梗花 黑色皮箱 追捕 真相 金色梦乡 宵待草夜情 玫瑰的名字 独眼少女 代码var str = \"\";for (let x of document.getElementsByClassName(\"title\")) { element = x.getElementsByTagName(\"a\").item(0); str += \"-[! [\" + element.innerHTML + \"](\"+ element.getAttribute(\"href\") +\")](\"++\")&lt;br&gt;\";}document.write(str);" }, { "title": "Go：Hello, 世界", "url": "/posts/go-hello-world/", "categories": "learn, golang", "tags": "Go语言, 编程", "date": "2022-09-07 12:51:14 +0000", "snippet": "hello, world按照惯例，我们从“hello, world”程序开始，创建helloworld.go文件如下：package mainimport \"fmt\"func main() { fmt.Println(\"Hello, 世界\")}go run和go build输入如下命令：go run hellworld将会输出“Hello, 世界”，和许多较新的语言一样，Go语言原生支持Unicode，无需做特殊处理即可处理所有国家的语言。Go是编译型的语言，采用如下命令生成可执行文件，并可直接执行：go build helloworld.go./helloworldpackage和importGo代码是通过package来组织的，在每个源文件开始都会用package指明属于哪个package。在本例中helloworld.go便属于package main。package main和其他package有所不同，它通常用来定义一个独立的可执行程序。在package后，紧跟着import来导入所需要的包，本例中即导入了fmt。函数在Go语言中，函数的声明为如下格式：func main(argc int, argv []string) int {}从前往后分别为func关键字、函数名、参数列表、返回值列表和函数体。和C语言不同，函数的返回值列表定义在函数名和参数列表的后方。这种定义方式对一些复杂的声明看起来会比C风格的定义方式要更为直观。考虑Go’s Declaration Syntax中介绍的某个例子，函数的参数和返回值均含有函数指针：C：int (*(*fp)(int (*)(int, int), int))(int, int)Go：f func(func(int,int) int, int) func(int, int) int这种靠后的声明显然更为直观，实际上Go的变量声明也是将参数类型后置，同样在许多场景下会显得更为直观而少歧义，例如指针声明。格式Go对格式要求较为严格，但同时也提供了gofmt工具以自动化格式代码。go的子命令fmt也是gofmt的封装，用来格式化指定包里或当前文件夹中的所有文件。参考 The Go Programming Language" } ]
